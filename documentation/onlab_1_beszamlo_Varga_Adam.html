<!DOCTYPE html>
<html>
<head>
<title>onlab_1_beszamlo_Varga_Adam.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast')
          ? 'dark'
          : 'default'
    });
  </script>
<h1 id="multitenant-%C3%B6tletkezel%C5%91-alkalmaz%C3%A1s-spring-alapokon---besz%C3%A1mol%C3%B3">Multitenant ötletkezelő alkalmazás Spring alapokon - Beszámoló</h1>
<p>Önálló laboratórium 2 - 2022/23/2</p>
<p>Varga Ádám Marcell</p>
<p>Konzulens: Forstner Bertalan</p>
<hr>
<h2 id="tartalom"><strong>Tartalom</strong></h2>
<ul>
<li><a href="#bevezet%C3%A9s">Bevezetés</a>
<ul>
<li><a href="#motiv%C3%A1ci%C3%B3">Motiváció</a></li>
<li><a href="#megval%C3%B3s%C3%ADtand%C3%B3-feladatok">Megvalósítandó feladat</a></li>
</ul>
</li>
<li><a href="#architekt%C3%BAra">Architektúra</a></li>
<li><a href="#felhaszn%C3%A1lt-technol%C3%B3gi%C3%A1k">Felhasznált technológiák</a>
<ul>
<li><a href="#angular">Angular</a></li>
<li><a href="#spring-boot-kotlin">Spring Boot (Kotlin)</a></li>
<li><a href="#mysql">MySQL</a></li>
</ul>
</li>
<li><a href="#front-end">Front-End</a>
<ul>
<li><a href="#n%C3%A9zetek">Nézetek</a></li>
</ul>
</li>
<li><a href="#back-end">Back-end</a></li>
<li><a href="#tov%C3%A1bbfejleszt%C3%A9si-lehet%C5%91s%C3%A9gek">Továbbfejlesztési lehetőségek</a></li>
<li><a href="#%C3%B6sszefoglal%C3%A1s">Összefoglalás</a></li>
</ul>
<div style="page-break-after: always;"></div>
<h2 id="bevezet%C3%A9s"><strong>Bevezetés</strong></h2>
<h3 id="motiv%C3%A1ci%C3%B3"><strong>Motiváció</strong></h3>
<p>Azért választottam ezt a témát, olyan témával akartam foglalkozni, amit továbbvihetek Diplomaterv 1 illetve 2 tárgyakra, mert elég nagy ahhoz, hogy 3 féléven keresztül tudjak benne mivel foglalkozni.</p>
<p>Emellett a témával lehetőségem van olyan dolgokat kipróbálni, amikkel eddig nem foglalkoztam. Ilyen például a Spring Boot rendszer megismerése és a multitenant architektúra implementálása.</p>
<p>Emellett az megvalósítandó alkalmazás, ami egy akár ipari környezetben is használható ötletkezelő rendszer fejlesztését is érdekes feladatnak találtam, hiszen alapjaiban véve hasonló felépítésű (csak más célt szolgáló) rendszereket ma már a szoftverfejlesztő cégek többsége használ a mindennapokban a feladatok kiosztásában. (Jira, Redmine, Trello)</p>
<h3 id="megval%C3%B3s%C3%ADtand%C3%B3-feladatok"><strong>Megvalósítandó feladatok</strong></h3>
<p>A félévben a fő célként azt tűztem ki, hogy az alkalmazás alapjait fektetem le, hogy a Diplomaterv 1 illetve 2 tárgyak keretében a már működő rendszert tudjam továbbfejleszteni új, speciálisabb feature-ökkel, modulokkal.</p>
<p>Ez alapján a félévre tervezett feladatok a következők voltak:</p>
<p><strong>Rendszer</strong></p>
<p>Az alkalmazás alapvetően 3 felhasználót támogat, a <strong>USER</strong>-t, a <strong>JURY</strong>-t és az <strong>ADMIN</strong>-t. Ezek a felhasználóknak különböző jogosultságaik vannak, amikkel az alkalmazás különböző részeihez férnek hozzá.</p>
<ul>
<li>
<p><strong>USER</strong></p>
<p>A USER felhasználó az oldalon limitált képességekkel rendelkezik. A listázott ötletdobozokat látja, amiket meg tud nyitni. Ezekbe az ötletdobozokba létrehozhat új ötleteket. A saját ötletét szerkesztheti, illetve töröleti, de más ötletét csak megnyitni tudja. Az ötleteket Like-olhatja, illetve ha már Like-olta, akkor a Like-ot visszavonhatja. Az ötlet kommentjeit Like/Dislikeolhatja (a sajátját is) illetve új kommentet is létrehozhat egy adott ötlethez. A saját kommentjét szerkeszteti.</p>
<p>Ezen felül hozzáfér a User oldal első részéhez, ami listázza a saját ötleteket és kommenteket.</p>
</li>
<li>
<p><strong>JURY</strong></p>
<p>A JURY felhasználónak már több lehetősége van interakcióba lépni az oldallal. A JURY felhasználók megkapják a USER felhasználók jogait, illetve új funkciókhoz is hozzájutnak.</p>
<ul>
<li>Ötletdobozok létrehozása</li>
<li>Ötletdobozokba érkező ötletek bírálása</li>
</ul>
<p>Ezen felül a JURY felhasználók hozzáférnek még a User oldal egy új részéhez is, ami listázza azokat az ötleteket, amikhez a felhasználó hozzá van rendelve mint kötelező bíráló, illetve azokat az ötleteket, amikhez már készített bírálatot.</p>
</li>
<li>
<p><strong>ADMIN</strong></p>
<p>Az ADMIN felhasználó az oldal Superusere, tehát minden joga megvan. Létrehozhat, szerkeszthet ötletdobozokat, a benne lévő ötleteket, kommenteket. A felhasználóknak ő állítja be a jogosultságait</p>
</li>
</ul>
<p><strong>Biztonság</strong></p>
<p>A rendszernek mind Front-End-en, mind Back-end-en meg kell valósítani biztonsági intézkedéseket, amikkel csak a megfelelő jogosultságú felhasználók érhetnek el a jogaiknak megfelelő funkciókat.</p>
<div style="page-break-after: always;"></div>
<h2 id="architekt%C3%BAra">Architektúra</h2>
<p>Az alkalmazást webes környezetben valósítottam meg, és mivel több feladatot is ellát (illetve még a jövőben bővítve is lesz), ezért 3 rétegű architektúra megvalósítása mellett döntöttem.</p>
<p><strong>Megjelenítési réteg:</strong> Angular 14</p>
<p><strong>Üzleti logikai réteg:</strong> Spring Boot Kotlin nyelven</p>
<p><strong>Perzisztencia:</strong> MySQL Adatbázis</p>
<p>Mind a kliens oldali Angular alkalmazásban, mind a szerver oldali Spring Boot alkalmazásban
törekedtem az adott keretrendszer által diktált struktúrák és konvenciók megtartására.</p>
<hr>
<p>Ez a Back-End rétegben megvalósult. A szerver megvalósítja a Controller-Service-Repository mintát.</p>
<p><img src="./images/beszamolo/architektura.png" alt="Architektúra"></p>
<p>A Controllerben vannak összegyűjtve a REST hívások, ezek a függvények hívják tovább az üzleti logikának a megvalósított függvényeit.</p>
<p>A Service-ben vannak az implementált függvények, amiket a Controller hív. Itt történik az adatok összeállítása, kiértékelése, a biztonság egy része.</p>
<p>A Repository mappa nyújtja a hidat az adatbázis és a JPA között.</p>
<hr>
<p>Front-End-en is törekedtem a helyes mappaszerkezet létrehozására, de az alkalmazás hamar túlnőtt az elsőre becsült méretén, így itt nem teljesült maradéktalanul a komponens alapú alkalmazás fejlesztés. Több komponens van amiket kisebb változásokkal újraimplementáltam. Ezeket általánosabb komponensekké ki lehetne vezetni.</p>
<div style="page-break-after: always;"></div>
<h2 id="felhaszn%C3%A1lt-technol%C3%B3gi%C3%A1k"><strong>Felhasznált technológiák</strong></h2>
<h3 id="angular"><strong>Angular</strong></h3>
<p><strong>Angular</strong>
Az Angular egy webes keretrendszer, amit a Google fejleszt. SPA (Single Page Application) létrehozására lett kitalálva, ami azt jelenti, hogy a megjelenített nézeteket nem a szerver generálja és statikus oldalakként küldi a kliens számára, hanem kliens oldalon kerülnek generálásra, és ezek a generált oldalak és komponensek dinamikusan vannak beillesztve a DOM-ba (Document Object Model). Ennek köszönhetően az SPA alkalmazások nagyon gyorsak és „mozgékonynak” tűnhetnek a végfelhasználók számára. A fejlesztésük is egyszerű, mivel az Angular is komponenseken alapul. A komponensek kisebb alkotóelemei az oldalnak, amik akár önállóan is működhetnek. Ezekből a kisebb komponensekből áll elő az oldal. Ezeket a komponensek úgy vannak tervezve, hogy újra felhasználhatóak legyenek az alkalmazás több részében is, így jelentősen kevesebb (akár semmiféle) kódismétlést tartalmaz az oldal forráskódja.</p>
<p><strong>Angular Material</strong></p>
<p>Az Angular Material szintén a Google által fejlesztett könyvtár, ami az Angular alkalmazásokhoz biztosít különböző előre létrehozott komponenst, amikkel a fejlesztés még gyorsabb és egyszerűbb. A könyvtár ezen felül egy nagyon jól definiált material designt is nyújt, ami könnyen használható a saját komponensek stílusozására is. Az alkalmazásban több komponens is Angular Material komponens, vagy abból lett átalakítva. Az egyedi stílusozást SCSS segítségével valósítottam meg, ahol erre szükség volt.</p>
<h3 id="spring-boot-kotlin"><strong>Spring Boot (Kotlin)</strong></h3>
<p>A Spring Boot egy nyílt forráskódú keretrendszer és egyben fejlesztési platform, amely lehetővé teszi a könnyű és gyors alkalmazásfejlesztést a Spring keretrendszerrel. A Spring Boot célja, hogy egyszerűsítse és gyorsítsa fel a Spring alapú alkalmazások létrehozását, konfigurálását és telepítését, így csökkentve a fejlesztési erőfeszítéseket és az alkalmazások bevezetésének időtartamát.</p>
<p>A Spring Boot támogatja a Kotlin nyelvet, és a Spring keretrendszer Kotlin-kompatibilis API-kat is kínál. Ez lehetővé teszi a fejlesztők számára, hogy Kotlinban írjanak Spring Boot alkalmazásokat, kihasználva a Kotlin nyelv nyújtotta előnyöket, például a rövidebb és olvashatóbb kódot, a csökkentett hibalehetőséget és a funkcionális programozás támogatását. Így a Spring Boot és a Kotlin kombinációja erőteljes és hatékony platformot nyújt az alkalmazásfejlesztéshez.</p>
<h3 id="mysql"><strong>MySQL</strong></h3>
<p>A MySQL egy többfelhasználós, többszálú relációs adatbázis kiszolgálásához használható szerver. A kora ellenére még most is az egyik legelterjedtebb adatbázis szerver, ami gyorsaságának, és nyílt forráskódjának köszönhető. A MySQL szerverek fejlesztése nagyon költséghatékony, emiatt rengeted keretrendszer támogatja a MySQL könnyű integrálását és ez alól a Go sem kivétel.</p>
<div style="page-break-after: always;"></div>
<h2 id="front-end"><strong>Front-End</strong></h2>
<h3 id="n%C3%A9zetek"><strong>Nézetek</strong></h3>
<p>Az alkalmazás kliens oldala több nézetet is tartalmaz, amik között a felhasználó (a jogaitól függően) szabadon navigálhat.</p>
<p><strong>Login/Register oldal</strong></p>
<p>Ez az oldal fogadja először a felhasználót. Az alkalmazás használata felhasználói fiókhoz kötött, ha nem vagyunk belépve akkor az alkalmazás funkcióit nem tudjuk használni, az oldalakat nem tudjuk látogatni. Ha a felhasználó rendelkezik fiókkal, akkor az email címével és jelszavával be tud lépni az alkalmazása. Ha még nem rendelkezik fiókkal, akkor a Register gomb megnyomásával egy regisztráló oldalra irányítódik át, ahol a vezetéknév, keresztnév, email és jelszó megadását követően tud fiókot létrehozni.</p>
<p><img src="./images/beszamolo/login.png" alt="Bejelentkező oldal"></p>
<p><strong>Ötletdoboz listázó oldal</strong></p>
<p>Ez az oldal tekinthető az alkalmazás főoldalának. Itt láthatóak az aktív ötletdobozok, melyekbe bárki ötletet írhat. Ezt a listázó doboz jobb fölső sarkában található <strong>Create</strong> gombbal tehetjük meg. A listázott ötletdobozokból kereshetünk is a keresőmező használatával, illetve a keresődoboz alján található lapozóval lapozhatunk is a találatok között, ha nem férnek ki az ötletdobozok egy oldalra. Az oldalak számát a felhasználó szabhatja meg (4, 8 illetve 12 ötletdoboz).</p>
<p>Ha adminként vagyunk belépve, akkor megnyithatjuk az ötletdobozokat menedzselő felületet.</p>
<p><img src="./images/beszamolo/idea_box_listing.png" alt="Ötletdoboz listázó oldal"></p>
<p><strong>Ötletdoboz menedzselő oldal</strong></p>
<p>Ez egy egyszerű listázó oldal, ahol az adminok gyorsan és egyszerűen hajthatnak végre műveleteket az ötletdobozokon.</p>
<p>A táblázatban az ötletdobozokat gyorsan törölhetjük, illetve megnyithatjuk a szerkesztő oldalukat. A törés gomb megnyomásakor egy felugró ablak figyelmeztet, hogy biztosan törölni akarjuk-e az ötletdobozt, és annak minden ötletét, az ötletek minden kommentjét.</p>
<p><img src="./images/beszamolo/idea_box_manage.png" alt="Ötletdoboz menedzselő oldal"></p>
<p><strong>Ötletdoboz Create/Edit</strong></p>
<p>Ez a felület két célt szolgál. Új ötletdobozt lehet itt felvenni, vagy egy már meglévő ötletdobozt szerkeszteni.</p>
<p>Az ötletdobozoknak Címet, leírást, kezdeti és zárási időpontot lehet adni. Ha admin felhasználóként vagyunk bejelentkezve, akkor ezen kívül még megjelenik egy táblázat, ami - hasonlóan mint az ötletdoboz menedzselő felületnél - egy gyors módot biztosít az ötletek szerkesztésére és törlésére.</p>
<p><img src="./images/beszamolo/idea_box_create_edit.png" alt="Ötletdoboz Create/Edit"></p>
<p><strong>Ötletdoboz</strong></p>
<p>Ezen a felületen láthatunk egy adott ötletdobozt és annak adatait, illetve a benne már leadott ötleteket. Az ötletek 4 nagyobb kategóriába sorolhatók.</p>
<ul>
<li>
<p><strong>SUBMITTED</strong></p>
<p>Ezek a friss ötletek. Amikor egy felhasználó létrehoz egy ötletet, akkor az ebbe a kategóriába kerül.</p>
</li>
<li>
<p><strong>REVIEWED</strong></p>
<p>Ebben a kategóriába akkor kerülnek az ötletek, ha az összes hozzárendelt bíráló lepontozta az ötletet. Ez az áthelyezés automatikus.</p>
</li>
<li>
<p><strong>APPROVED/DENIED</strong></p>
<p>A review során összegyűlt pontok alapján az admin dönthet úgy, hogy az adott ötlet megfelelő, ekkor elfogadja az ötletet. Ebben az esetben az ötlet átkerül az APPROVED státuszba. Ellenkező esetben az ötlet a DENIED státuszba kerül. Ez az áthelyezés nem automatikus.</p>
</li>
</ul>
<p>Az admin felhasználó az ötletek státuszát direktben is állíthatja.</p>
<p>A felületen a már megszokott helyen létrehozhatunk új ötletet az ötletdobozba, illetve admin jogosultsággal az ötletdoboz szerkesztőfelülete is megnyitható.</p>
<p><img src="./images/beszamolo/idea_box.png" alt="Ötletdoboz"></p>
<p><strong>Ötlet Create/Edit</strong></p>
<p>Hasonlóan mint az Ötletdoboznál, ez a felület és két célt szolgál, ötlet létrehozását és módosítását. A felületen megadható az ötlet címe, leírása. Hozzáadhatunk már létező Tag-eket, illetve új Tag-eket is felvehetünk. Az ötlethez itt tudunk hozzárendelni Bírálókat.</p>
<p><img src="./images/beszamolo/idea_create_edit.png" alt="Ötlet Create/Edit"></p>
<p><strong>Ötlet</strong></p>
<p>Ez a felület 4 alrészből áll, ezek: az Idea, a Details, a Comments illetve a Scores rész. Az első három részből a felületen mindig csak 1 látható, a Scores rész azonban a képernyő jobb szélén mindig megjelenik.</p>
<p>Az ötleteket lehet like-olni is a jobb fölső sarokban. Itt a like gomb mellett láthatjuk, hogy hány ember like-olta eddig és az utolsó likeoló nevét is láthatjuk. Abban az esetben, ha az utolsó lájkoló mi vagyunk, akkor a felület a &quot;You&quot;-t fogja kiírni.</p>
<p><img src="./images/beszamolo/idea.png" alt="Ötlet"></p>
<ul>
<li>
<p><strong>Idea:</strong>
Az Idea fülön található a leírás, illetve a későbbiekben ide lehet még több adatot felvinni.</p>
</li>
<li>
<p><strong>Details:</strong>
Itt találhatóak az alap adatai az ötletnek, mint például az, hogy ki csinálta, mikor, és hogy éppen milyen státuszban van az ötlet. Itt látható, hogy milyen Tag-ekkel van ellátva, illetve mely bírálók vannak az ötlethez adva.</p>
</li>
<li>
<p><strong>Comments:</strong>
Itt láthatóak az ötlethez fűzött kommentek. Ez az oldal részletesebb mint a többi, így ez a következő részben részletesen kifejtem.</p>
</li>
</ul>
<p><strong>Comment</strong></p>
<p>Ez az aloldal arra hívatott, hogy az ötletekre lehessen kommenteket írni. Ezt az aloldal tetején lévő szövegdobozból tudjuk megtenni. Alatta láthatjuk a már létező kommenteket. Ezeket a kommenteket lehet like-olni. itt a likeolás és annak kiírása ugyanúgy működik, mint az ötleten lévő like rendszer. A felhasználó a saját maga által írt kommenteket tudja szerkeszteni. Ekkor a kommentnél megjelenik egy &quot;Edited&quot; szöveg, jelezve, hogy a komment szerkesztve lett. Az admin felhasználók bárkinek a kommentjét szerkeszthetik.</p>
<p><img src="./images/beszamolo/idea_comments.png" alt="Comment"></p>
<p><strong>Score</strong></p>
<p>Ez az oldal valamilyen formában létrejött, de a kitűzött céloknak majdnem semmilyen formában nem felel meg, így ennek a szolgáltatásnak a fejlesztésére csak a következő félévben lesz lehetőség.</p>
<div style="page-break-after: always;"></div>
<h2 id="back-end"><strong>Back-End</strong></h2>
<p>Ahogy már említettem, az alkalmazás szerver oldala egy Spring Boot alkalmazás, amit Kotlin nyelven írtam. Az alkalmazás követi a Spring jól bevált struktúráját, azaz megtalálhatóak a Controllerek, a modellek, a repositoryk és a servicek. Ezen felül két mappa is a struktúra részét képezi, a mapperek és a security</p>
<h3 id="controller"><strong>Controller</strong></h3>
<p>Itt találhatók az endpointok, amiken keresztül az alkalmazás fogadja a kéréseket. A kérések az /api/*** url-en érhetőek el. Ezek az endpointok kérés érkezése esetén a service mappában implementált függvényeket hívják meg. Azok az endpontok amik listát adnak vissza, rendelkeznek szűrési és paginálási lehetőségekkel is. Ilyen például az ötletdobozok listázása.</p>
<pre class="hljs"><code><div>@GetMapping(&quot;/idea-box&quot;)
    fun getIdeaBoxes(
        @RequestParam(&quot;s&quot;, defaultValue = &quot;&quot;) s: String,
        @RequestParam(&quot;sort&quot;, defaultValue = &quot;&quot;) sort: String,
        @RequestParam(&quot;page&quot;, defaultValue = &quot;1&quot;) page: Int,
        @RequestParam(&quot;items&quot;, defaultValue = &quot;12&quot;) items: Int
    ): ResponseEntity&lt;*&gt; {
        var direction = Sort.unsorted()
        when(sort) {
            &quot;newest&quot; -&gt; direction = Sort.by(Sort.Direction.DESC, &quot;startDate&quot;)
            &quot;oldest&quot; -&gt; direction = Sort.by(Sort.Direction.ASC, &quot;startDate&quot;)
            &quot;closing&quot; -&gt; direction = Sort.by(Sort.Direction.ASC, &quot;endDate&quot;)
        }
        return ideaBoxService.getIdeaBoxes(s, PageRequest.of(page-1, items, direction))
    }
</div></code></pre>
<h3 id="model"><strong>Model</strong></h3>
<p>Az alkalmazás modell szerkezete nem egyedi módon követi a DAO-DTO mintát. Ez azt jelenti, hogy az alkalmazásban 3-féle modell típus tartozik minden objektumhoz, ezek a <strong>model</strong>, a <strong>dto</strong> és a <strong>slimDto</strong>.</p>
<ul>
<li>
<p><strong>Model</strong></p>
<p>Ez írja le a legbővebben az objektumokat, és ebben a formában kerülnek az objektumok tárolásra az adatbázisban is. Ebben a leírásban találhatók az objektumok összekapcsolására szolgáló adatbázis kapcsolatok is, amiket a JPA választ majd szét, hogy relációs adatbázisba lehessen ültetni.</p>
<p>A JPA segítségével könnyen kezelhetők az objektumok közötti egy-egy, egy-több, több-több kapcsolatok. Erre egy példa:</p>
<pre class="hljs"><code><div>@OneToMany(mappedBy = &quot;idea&quot;, fetch = FetchType.LAZY, cascade =   [CascadeType.ALL], orphanRemoval = true)
var comments: MutableList&lt;Comment&gt;?,

@ManyToOne
@JoinColumn(name = &quot;ideaBox_id&quot;)
var ideaBox: IdeaBox,
</div></code></pre>
<p>Ebben a példában például egy több-több kapcsolatot láthatunk, ahol az ötlethez kapcsoljuk a hozzá tartozó kommenteket. Itt látható, hogy az ötlet törlésénél a kommentek is törlésre kerülnek. Ezen felül egy egy-több kapcsolat is látható, amikor az ötletdobozok több ötletet is tartalmazhatnak, de egy ötlet csak egy ötletdobozhoz tartozhat.</p>
</li>
<li>
<p><strong>Dto</strong></p>
<p>A Dto (Data Transfer Object) feladata, hogy ne minden adat kerüljön kiküldésre a kliens felé, hanem csak azok, amikre valóban szükség van, illetve, hogy a kényes adatok ne kerüljenek ki. Ez egy védelmet is biztosít az adatbázisnak.</p>
</li>
<li>
<p><strong>SlimDto</strong></p>
<p>A SlimDto-k feladata az, hogy a Dto-knál küldött kapcsolódó adatok ne az egész objektumot küldjék, hanem csak a feltétlen szükséges adatokat, amikkel lekérhető a szerverről a teljes objektum, ha erre szükség van. Ebben általában csak id-k, illetve 1-2 listázás és nevesítés céljából használt adat utazik. Ebben az adattípusban már nincs utalás az esetleges al-objektumaira, így nem keletkezik végtelen utalás az adatok között.</p>
</li>
</ul>
<h3 id="mapper"><strong>Mapper</strong></h3>
<p>A Mapperben olyan függvények találhatóak, amik a különböző modelltípusokon végeznek konverziókat. 4 Féle konverziót valósítottam meg.</p>
<ul>
<li>modelToDto</li>
<li>modelToSlimDto</li>
<li>dtoToModel</li>
<li>slimDtoToModel</li>
</ul>
<h3 id="repository"><strong>Repository</strong></h3>
<p>A repository mappában vannak azok a kódok, amik segítségével a JPA az egymásba ágyazott objektum struktúrából leképez egy relációs adatbázisba ültethető adatmodellt. A modellben az annotációkkal ellátott kapcsolatokból kapcsolótáblák képződnek. Ezen felül szűrési és keresési függvények is létrehozhatók itt.</p>
<p>Erre példa a UserRepository findJuries függvénye, ami a felhasználók közül visszaadja azokat, akiknek a szerepköre bíráló vagy admin.</p>
<pre class="hljs"><code><div>@Query(&quot;SELECT u FROM User u WHERE u.role='Jury' OR u.role='ADMIN'&quot;)
    fun findJuries(): List&lt;User&gt;
</div></code></pre>
<h3 id="security"><strong>Security</strong></h3>
<p>Az alkalmazás biztonságáért a spring security és JWT tokene alkalmazása felel. A felhasználó bejelentkezéskor illetve regisztrációkor kap egy JWT-t, amit eltárol. A belső rendszer minden endpointja csak akkor látogatható, ha a felhasználó rendelkezik érvényes JWT-vel. Bizonyos endpoint csak akkor látogatható, ha a felhasználó jogosultsági köre is engedélyt ad rá (a bírálást csak jury és admin felhasználó végezheti).</p>
<h3 id="service"><strong>Service</strong></h3>
<p>A service rétegben vannak az alkalmazás által használt függvények implementációi. Ezek hívódnak meg amikor az bejövő hívás érkezik az alkalmazásban. Itt hívódnak az adatbázis műveletek, illetve itt is vannak biztonsági intézkedések. (Csak a bejelentkezett felhasználó szerkeszthet egy adott commentet).</p>
<pre class="hljs"><code><div>fun editComment(comment: CommentSlimDto): ResponseEntity&lt;*&gt; {
        val authentication = SecurityContextHolder.getContext().authentication
        if(comment.owner.email != authentication.name) {
            return ResponseEntity(
                WebResponse(
                    code = HttpStatus.UNAUTHORIZED.value(),
                    message = &quot;You dont have permission to do that!&quot;,
                    data = null
                ),
                HttpStatus.UNAUTHORIZED
            )
        }
        val originalComment = commentRepository.findById(comment.id).orElse(null)
            ?: return ResponseEntity(
                WebResponse(
                    code = HttpStatus.NOT_FOUND.value(),
                    message = &quot;Cannot find Comment with this id $comment.id!&quot;,
                    data = null
                ),
                HttpStatus.NOT_FOUND
            )

        originalComment.isEdited = true
        originalComment.text = comment.text

        return ResponseEntity.ok(
            WebResponse&lt;CommentDto&gt;(
                code = HttpStatus.OK.value(),
                message = &quot;Comment successfully edited!&quot;,
                data = commentMapper.modelToDto(commentRepository.saveAndFlush(originalComment))
            )
        )
    }
</div></code></pre>
<div style="page-break-after: always;"></div>
<h2 id="tov%C3%A1bbfejleszt%C3%A9si-lehet%C5%91s%C3%A9gek"><strong>Továbbfejlesztési lehetőségek</strong></h2>
<p>Az alkalmazás egy jelentős része, a pontozás nem úgy valósult meg, mint ahogy azt az elején terveztem. Illetve úgy valósult meg, mivel az elején sokkal kisebbre terveztem, mint amekkora része ez az alkalmazásnak. Emiatt ez a rész befejezetlen maradt ennek a félévnek a végére. A tervek azonban készen állnak, hogy implementáljam a következő (diplomaterv 1) félévben.</p>
<h3 id="%C3%B6tletdoboz-%C3%A9letciklus"><strong>Ötletdoboz életciklus</strong></h3>
<p>Az egész rendszer életciklusát újra kellett gondolni az első tervezés után. Jelenleg a rendszerben az ötletdobozoknak és a pontozásnak nincsen végcélja.</p>
<p>A következő félévben a következő rendszert szeretném implementálni:</p>
<p><img src="./images/beszamolo/ideabox_life_cycle.png" alt="Ötletdoboz életciklus"></p>
<p>Az ötletdoboz életciklusa a következő lesz:</p>
<ul>
<li>
<p><strong>Ötletdoboz létrehozás</strong></p>
<p>Ahogy a jelenlegi rendszerben is, az ötletdobozt el lehet majd készíteni, névvel, leírással és egyéb adatokkal ellátni.</p>
</li>
<li>
<p><strong>Kötelező bírálók beállítása</strong></p>
<p>Az ötletdoboznak be lehessen állítani kötelező bírálókat, akik majd az adott dobozba érkező ötleteket bírálják. Ezen felül ötletenként lehet majd egyéb bírálókat is felvenni, de ezek a bírálók, amik itt beállításra kerülnek alapértelmezetten szerepelni fognak minden beérkező ötletnél.</p>
</li>
<li>
<p><strong>Bírálási szempontok beállítása</strong></p>
<p>Az ötletdobozhoz egy egyedi bírálási szempontokat tartalmazó bírálólapot kell majd összeállítani az adminnak. Ebben a bírálólapban minden bírálási szempontnak szerepelni kell, és minden bírálási szemponthoz egy bírálási módszert lehet majd hozzárendelni (csillagos, csúszkás, szöveges). Ezek után az ötletdoboz aktívvá válik, és megnyílik a felhasználóknak az ötletgyűjtésre.</p>
</li>
<li>
<p><strong>Beérkező ötletek bírálása</strong></p>
<p>A beérkezett ötletek a bíráló bizottság tagjainál megjelenik, ha kötelező bírálói az ötletnek. Ők az ötletek bírálását elvégzik, és az Ötlet életciklusának a végén az ötlet valamelyik sávba kerül. Erről részletesebben az <a href="#%C3%B6tlet-%C3%A9letciklus">ötlet életciklusában</a> írok.</p>
</li>
<li>
<p><strong>Ötletdoboz lezárása</strong></p>
<p>Az ötletdoboz határideje után már nem fogad több ötletet, azaz lezáródik. Az beérkező ötletek még bírálásra kerülnek, de visszaküldésre már nincs lehetőség.</p>
</li>
<li>
<p><strong>Eredmények</strong></p>
<p>Az elbírált és elfogadott ötletek kihirdetésre kerülnek.</p>
</li>
</ul>
<h3 id="%C3%B6tlet-%C3%A9letciklus"><strong>Ötlet életciklus</strong></h3>
<p>Az ötletek tervezett életciklusa az alábbi képen látható:</p>
<p><img src="./images/beszamolo/idea_life_cycle.png" alt="Ötlet életciklusa"></p>
<ul>
<li>
<p><strong>Ötlet létrehozva</strong></p>
<p>Az ötletet a felhasználó létrehozta. Ilyenkor az ötlethez hozzákerülnek a szülő ötletdobozából a kötelező bírálók, de a felhasználó maga is adhat hozzá új bírálókat.</p>
</li>
<li>
<p><strong>Ötlet minden bíráló által bírálva</strong></p>
<p>Ha az ötletet minden hozzárendelt bíráló lepontozta, akkor az automatikusan átkerül a REVIEWED oszlopba és ADMIN beavatkozásra vár.</p>
</li>
<li>
<p><strong>Döntés</strong></p>
<p>Az admin dönthet arról, hogy az ötletet elfogadja, elutasítja vagy visszaküldi. Amennyiben elfogadja vagy elutasítja, akkor az ötlet életciklusa véget ér. Ha visszaküldi javításra, akkor visszakerül a submitted státuszba, és a pontozások lekerülnek róla.</p>
</li>
</ul>
<p>Az ötleteknél a SUBMITTED és REVIEWED státuszban ha a felhasználó szerkeszti az ötletet, akkor arról az összes eddigi pontozás lekerül.</p>
<p>Az ötletek bírálásánál az admin egy összesítő oldalon látja a szempontokhoz összegyűlt átlagos értékeket, esetleg ábrán, grafikonon, illetve a szöveges hozzászólásokat. Ezek alapján hozza meg a végleges döntést.</p>
<div style="page-break-after: always;"></div>
<h2 id="%C3%B6sszefoglal%C3%A1s"><strong>Összefoglalás</strong></h2>
<p>A félév során az alapvető alkalmazás elég nagy részét sikerült implementálni. A hátralévő pontozási rendszer nem kalkulált méretei miatt az a rész nem lett befejezve.</p>
<p>A félév során sokat tanultam mind front-end, mind backend tervezés kapcsán. A back-end alkalmazásom struktúrájában jól működik, és könnyű továbbfejleszteni. Itt rengeteget tanultam a Spring keretrendszerről hiszen ez volt az első komolyabb alkalmazás, amit írtam benne. A spring security is új rendszer volt, de a félév végére sikerült belemélyednem és megvalósítanom egy implementációt.</p>
<p>Front-end részről az alkalmazás bizonyos részei (mivel előre nem kalkulált méreteket öltött) a félév végére kezdtek összecsúszni, így a front-end-re egy refaktorálás ráfér, ahol a különböző felelősségek jobban szét válnak akár modulok formájában is</p>

</body>
</html>
